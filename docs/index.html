<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="utf-8">
		<title>Three.js Practice</title>

		<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script>
		<script src="js/three.min.js"></script>
		<script type="text/javascript" src="js/Octree.js"></script>
		<script src="js/renderers/Projector.js"></script>	
		<script src="js/controls/TrackballControls.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>
		<script src="js/libs/stats.min.js"></script>

	</head>
	<body>
		<script>
			//DOM
			var container;

			//操作
			var controls;
			var octree;

			//PCD

			//constract
			var zoom = 0.8;
			var width=640*zoom;
			var height=480*zoom;
			var z0 = (height/2)/Math.tan(Math.PI/8);

			var dgeometry = null;
			var dmaterial = null;
			var group = null;

			var depthData = {
				"points": 0,
				"vertices": [],
				"colors": []
			};
			var sketchData = {
				"lines": 0,
				"vertices": [],
				"colors": [],
				"colors_": [],
				"lineWidth":[]
			};

			function ready(){

				// DOM
				container = document.createElement('div');
				document.body.appendChild(container);


				// Scene
				var scene = new THREE.Scene();


				// Camera
				var camera = new THREE.PerspectiveCamera(45, width/height, 10, 150000);
				camera.position.set(0,0,z0);

				// create octree

				octree = new THREE.Octree( {
					// uncomment below to see the octree (may kill the fps)
					//scene: scene,
					// when undeferred = true, objects are inserted immediately
					// instead of being deferred until next octree.update() call
					// this may decrease performance as it forces a matrix update
					undeferred: false,
					// set the max depth of tree
					depthMax: Infinity,
					// max number of objects before nodes split or merge
					objectsThreshold: 8,
					// percent between 0 and 1 that nodes will overlap each other
					// helps insert objects that lie over more than one node
					overlapPct: 0.15
				} );

				//Axis
				drawAxis();


				//Depth Objects
				group = new THREE.Object3D();
				dgeometry = new THREE.Geometry();
				dgeometry.dynamic = true;
				dgeometry.colors = depthData.colors;
				dgeometry.vertices = depthData.vertices;
				var dmaterial = new THREE.PointsMaterial({
					size: 10,
					vertexColors: true
				});
				particles = new THREE.Points(dgeometry, dmaterial);
				//				group.add(particles);

				//Test Line Objects 2

				var tgeometry = new THREE.BufferGeometry();
				var tmaterial = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors,linewidth: 10});

				var positions = [];
				var next_positions_index = 0;
//				var colors = [];
				var indices_array = [];

				//配列にpushされる値を全て同じ値にする
				var orign1 = 0.9464358738441498;
				var orign2 = 0.7707642675850559;
//				var orignColor = THREE.Color( 0x1f739e );
				console.log("orign color ",orign1,orign2);
				
				function add_vertex(v,idx) {
					if (next_positions_index == 0xffff) throw new Error("Too many points");

					positions.push(v.x, v.y, v.z);
					//色情報を追加する
//					colors.push(Math.random()*0.5+0.5, Math.random()*0.5+0.5, 1);//

					//color情報からidxに相当するTHREE.colorを抜き出し、hsl値に変換して登録する

					var rgb = sketchData.colors[idx].toArray();//だめ
					sketchData.colors_.push(rgb[2],rgb[1],rgb[0]);//BGRの順に登録

					return next_positions_index++;
				}
				// simple Koch curve

				function snowflake_iteration(p0, p4, depth,idx) {
					if (--depth < 0) {
						var i = next_positions_index-1; // p0 already there
						add_vertex(p4,idx);
						indices_array.push(i, i+1);
						return;
					}
				}

				function snowflake(points, loop, x_offset,idx) {
					add_vertex(points[0],idx);
					for (var p_index=0, p_count=points.length-1; p_index != p_count; ++p_index) {
						snowflake_iteration(points[p_index], points[p_index+1], 0,idx);
					}
				}

				//矩形の生成
				for(var i=0; i<sketchData.lines;i++){
					if(sketchData.vertices[i].length!=0){//線が登録されていれば
						snowflake
						(
							sketchData.vertices[i],
							false, 600,i
						);
					}
				}
				tgeometry.setIndex( new THREE.BufferAttribute( new Uint16Array( indices_array ), 1 ) );
				tgeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( positions ), 3 ) );
				//				tgeometry.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array(colors), 3 ) );//なんか綺麗なやつ
				tgeometry.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array(sketchData.colors_), 3 ) );

				tgeometry.attributes.position.needsUpdate = true;
				tgeometry.attributes.color.needsUpdate = true;
				tgeometry.colors = sketchData.colors;



				mesh = new THREE.LineSegments( tgeometry, tmaterial );
				//				mesh.position.x -= 1200;
				//				mesh.position.y -= 1200;

				parent_node = new THREE.Object3D();
				parent_node.add(mesh);

				group.add( parent_node );



				scene.add(group);


				// Renderer
				var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				renderer.setSize(width, height);
				renderer.setClearColor(0xffffff, 0);
				renderer.setPixelRatio(window.devicePixelRatio);
				container.appendChild(renderer.domElement);


				//controles
				controls = new THREE.TrackballControls( camera );

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];
				controls.addEventListener( 'change', render );

				animate();

				function animate() {
					requestAnimationFrame(animate);
					controls.update();
					render();
				}

				function render() {
					renderer.render(scene, camera);
				}


				function resize() {
					camera.updateProjectionMatrix();
					renderer.setSize(window.innerWidth, window.innerHeight);
				}

				function createGeometry(count) {
					var geometry = new THREE.Geometry();

					for (var i = 0; i < count; i++) {
						var x = Math.random() * 1000 - 500;
						var y = Math.random() * 1000 - 500;
						var z = Math.random() * 1000 - 500;
						var particle = new THREE.Vector3(x, y, z);
						particle.velocity = new THREE.Vector3(0, -Math.random(), 0);
						geometry.vertices.push(particle);
					}
					return geometry;
				}

				//座標系
				function drawAxis(){
					// line
					//create a blue LineBasicMaterial
					var material = new THREE.LineBasicMaterial({ color: 0x0000ff });

					var geometry = new THREE.Geometry();

					var lineLenght = 10000;
					geometry.vertices.push(new THREE.Vector3(0, 0, 0));
					geometry.vertices.push(new THREE.Vector3(lineLenght, 0, 0));
					geometry.vertices.push(new THREE.Vector3(0, 0, 0));
					geometry.vertices.push(new THREE.Vector3(0, lineLenght, 0));
					geometry.vertices.push(new THREE.Vector3(0, 0, 0));
					geometry.vertices.push(new THREE.Vector3(0, 0, lineLenght));

					var line = new THREE.Line(geometry, material);

					scene.add(line);
				}
				window.addEventListener('resize', resize, false);

				window.addEventListener( 'keydown', function ( event ) {
					console.log("keydown", event.keyCode);
					switch ( event.keyCode ) {

						case 81: // Q
							break;

						case 17: // Ctrl
							break;

						case 87: // W
							break;

						case 69: // E
							break;

						case 82: // R
							break;

						case 187:
						case 107: // +, =, num+
							break;

						case 189:
						case 109: // -, _, num-
							break;

						case 13: //0 reset
							console.log("controls",controls);

							controls.reset();
							break;
					}

				});

				window.addEventListener( 'keyup', function ( event ) {

					switch ( event.keyCode ) {

						case 17: // Ctrl
							break;
					}
				});
			};

			//PCDの読み込み
			function init_save(){
				//読み込み処理が全部終わったら続く処理を行う
				$.ajax({
					url:dataPath,
					success: function(data){
						var data = data.split(/\r\n|\r|\n/);// 行ごとに分割
						//PCDは10行目から
						for(var i=10;i<data.length;i++){
							var row = [];
							var d = data[i].split(' ');
							//							console.log(d);
							for(var j=0 ; j<4 ; j++){
								if(j<2){//座標情報
									//xy座標
									row.push(parseFloat(d[j]));
								}else if(j==2){
									//z座標
									row.push(parseFloat(d[j])*-1+z0);
								}else{
									//色情報
									var c = new THREE.Color(parseInt(d[j]));// color 10進数
									depthData.colors.push(c);
								}
							}
							depthData.vertices.push(new THREE.Vector3(row[0],row[1],row[2]));
						}
					}
				}).done(function(){
					ready();
				});
			}
			function init(){
				//読み込みの実行
				var path = [
					'data/PointCroudData.pcd',
					'data/Sketch.txt'
				];

				var dataList = [];


				for (var i = 0; i <= path.length; i++) {
					dataList.push($.ajax({ // $.ajaxの戻り値をdataList配列に格納
						url: path[i]
					}));
				}
				//読み込み終了後の処理
				$.when.apply($, dataList).done(function () {
					// 結果は仮引数に可変長で入る **順番は保証されている**
					// 取り出すには arguments から取り出す
					// argumentsはそれぞれ [data, textStatus, jqXHR] の配列になっている

					//全てを取り出す
					//					for (var i = 0; i < arguments.length-1; i++) {
					//						var result = arguments[i];
					//						console.log(i,result[0]);//data
					//						//						console.log(i,result[1]);//textStatus
					//						//						console.log(i,result[3]);jqXHR
					//						console.log("test",i);
					//					}

					//それぞれについて処理する 0番目はPCD,1番目はsketchデータ
					persePCD(arguments[0][0]);//デプスデータの準備
					perseSketchData(arguments[1][0]);//スケッチデータの準備
					ready();//描画
				});
			}

			function persePCD(data){
				var data = data.split(/\r\n|\r|\n/);// 行ごとに分割
				//PCDは10行目から
				for(var i=10;i<data.length;i++){
					var d = data[i].split(' ');

					//色情報
					var c = new THREE.Color(parseInt(d[3]));// color 10進数
					depthData.colors.push(c);

					//座標情報
					var px = parseFloat(d[0]);
					var py = parseFloat(d[1]);
					var pz = parseFloat(d[2]*-1+z0);

					depthData.vertices.push(new THREE.Vector3(px,py,pz));
				}
			}
			function perseSketchData(data){
				//スケッチデータの処理
				//形式 1行ストローク [色 太さ P1座標 P1座標 P2座標 P3座標...]

				data = data.split(/\r\n|\r|\n/);// 行ごとに分割
				for(var i=0;i<data.length;i++){
					var d = data[i].split(' ');

					//色
					var c = new THREE.Color(parseInt(d[0]));// color 10進数
					sketchData.colors.push(c);

					//hsl値で保存
					//					var c_hsl = c.getHSL();
					//					sketchData.colors_hsl.push(c_hsl.h, c_hsl.s, c_hsl.l);

					//線の太さ
					var w = parseInt(d[1]);// 太さ情報
					sketchData.lineWidth.push(w);
					var points = [];

					//座標情報
					for(var j=2 ; j<d.length ; j=j+3){
						var px = parseFloat(d[j]);
						var py = parseFloat(d[j+1]);
						var pz = parseFloat(d[j+2]*-1+z0);
						var p = new THREE.Vector3(px,py,pz);
						points.push(p);
					}
					sketchData.vertices.push(points);
				}
				sketchData.lines = sketchData.colors.length;
			}

			//HTMLが読み込まれたら実行
			window.addEventListener('load', init, false);

			function RGBtoHSV(r, g, b) {
				if (arguments.length === 1) {
					g = r.g, b = r.b, r = r.r;
				}
				var max = Math.max(r, g, b), min = Math.min(r, g, b),
					d = max - min,
					h,
					s = (max === 0 ? 0 : d / max),
					v = max / 255;

				switch (max) {
					case min: h = 0; break;
					case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
					case g: h = (b - r) + d * 2; h /= 6 * d; break;
					case b: h = (r - g) + d * 4; h /= 6 * d; break;
				}

				return {
					h: h,
					s: s,
					v: v
				};
			}
			function HSLtoHSV(h, s, l) {
				if (arguments.length === 1) {
					s = h.s, l = h.l, h = h.h;
				}
				var _h = h,
					_s,
					_v;

				l *= 2;
				s *= (l <= 1) ? l : 2 - l;
				_v = (l + s) / 2;
				_s = (2 * s) / (l + s);

				return {
					h: _h,
					s: _s,
					v: _v
				};
			}

		</script>
	</body>
</html>